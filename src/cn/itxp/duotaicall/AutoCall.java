package cn.itxp.duotaicall;

/**
 * 多态中JVM准确的方法调用机制：动态方法调用机制
     （1）和静态调用一致
          JVM在执行主方法中的方法调用时首先将源代码编译成一条指令invokevirtual #15
 *        该条指令指向的是当前类的常量池中的第15个常量表的索引项
 *        该常量表记录的是fun信息的符号引用（包括所在类名 方法名 返回类型）
 *        然后根据这个引用找到fun所在类的全限定名 cn.itxp.duotaicall.Father
 *   （2）接着再Father类型的方法表中查找到fun,如果找到，则将方法fun在方法表中的
 *        索引项记录到当前类的常量池中的第15个常量表中（常量池解析）
 *     注意：如果没有找到fun方法，直接编译失败 无论子类中有没有该方法
 *   （3）常量池解析后就相当于类加载完成，但是在执行该条指令之前，该指令
 *        会根据操作数栈中创建好的son对象的引用，找到堆中Son对象 然后在Son对象的方法表中
 *        找到fun方法的，再通过直接地址找到该方法字节码所在的内存空间
 *   （4）最后调用该条指令，最终结果就是在没有进行判断的条件下准确的执行了
 *        子类重写父类的方法
 *   很明显，只是根据对象声明father声明类型Father还不能确定调用fun的位置，
 *   必须根据father在堆中实际创建对象的类型Sun来确定方法的位置。
 *   这种在程序运行过程中，通过动态创建的对象的方法表来定位方法的方式，
 *   我们叫做动态绑定机制
 *
 * 通过以上比较总结出多态的定义和优点：
 *       定义：多态是指同一操作作用于不同对象，可以有不同的解释，因为会出现不同的结果
 *            例如：父类有个fun方法，他有三个字类都重写了这个方法
 *            在主函数中定义三个个父类类型的对象 但是new的类型是三个子类对象
 *            同时调用这三个对象的fun方法会有不同的结果
 *        多态的优势：消除了类型之间的耦合关系，令我们把一个对象不当做它所属的
 *             特定类型来对待，而是当做其基类的类型来对待
 *             其次，多态改善了代码的组织结构和可读性，同时保证了可扩展性
 *      比如在测试类中定义一个方法perform(基类)，如果它传入的参数类型是基类
 *       那么在调用该方法时完全可以，将该基类的所有子类作为参数传进去
 *       反之，perform(子类1) perform(子类2) perform(子类3)
 *       可以这样定义perform的多个重载方法，但是这样代码的结构看起来比较繁琐
 */
public class AutoCall {
    public static void main(String[] args) {
        Father father = new Son();//多态
        father.fun();
    }
}
