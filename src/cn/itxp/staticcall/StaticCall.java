package cn.itxp.staticcall;
/**
 * 静态方法调用机制：
 *    JVM在执行主方法中的方法调用时首先将源代码编译成一条指令invokestatic #13
 *     （1）该条指令指向的是当前类的常量池中的第13个常量表的索引项
 *         该常量表记录的是f1信息的符号引用（包括所在类名 方法名 返回类型）
 *          然后根据这个引用找到f1所在类的全限定名 Father
 *     （2）紧接着加载链接和初始化Father类
 *     （3）然后在Father类所在的方法区中找到f1方法的直接地址，并把该信息记录到
 *          StaticCall类常量池索引为13的常量表中，该过程叫做常量池解析
 *     （4）在JVM确定了f1的具体位置之后，就可以调用该方法，并且执行方法中的指令了
 *通过常量池解析，JVM就会明确知道f1在内存中的具体位置
 * 以上工作都是在程序编译阶段就已经完成了，这种在编译阶段就能
 * 确定调用哪个方法的方式叫做静态绑定机制
 * 其中还包括被private修饰的私有方法 被final修饰的禁止子类覆盖的方法
 * 都会被加载为指令，然后由JVM通过静态绑定机制来调用该方法
 */
public class StaticCall {
    public static void main(String[] args){
        Father.f1();//此处调用静态方法
    }
}
